#!/usr/bin/env python3
import argparse
import os
import sys
import base64
import requests
import zipfile
import io
import platform
import subprocess

__version__ = "1.4.0"

class GitHubManager:
    def __init__(self, token):
        self.token = token
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json"
        }
        self.user = self.get_current_user()

    def get_current_user(self):
        """Fetches the authenticated user's username."""
        url = f"{self.base_url}/user"
        response = requests.get(url, headers=self.headers)
        if response.status_code == 200:
            return response.json()['login']
        else:
            print(f"‚ùå Connection Failed: Invalid token (HTTP {response.status_code})")
            sys.exit(1)

    def list_contents(self, repo_name, limit=100, mode="all", path=""):
        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{path}"
        response = requests.get(url, headers=self.headers)

        if response.status_code == 200:
            items = response.json()
            items.sort(key=lambda x: (x['type'] != 'dir', x['name'].lower()))

            print(f"\nüìÇ Contents of '{repo_name}' (Limit: {limit}):")
            print("-" * 50)
            
            count = 0
            for item in items:
                if count >= limit: break
                item_type = item['type']
                name = item['name']

                if mode == "fi" and item_type != "file": continue
                if mode == "fo" and item_type != "dir": continue

                if item_type == "dir":
                    print(f"üìÅ {name}/")
                    count += 1
                elif item_type == "file":
                    print(f"üìÑ {name}")
                    count += 1
            
            if count == 0: print("   (No items found matching criteria)")
            print("-" * 50 + "\n")
        else:
            print(f"‚ùå Failed to fetch contents: {response.json().get('message')}")

    def rename_repo(self, old_name, new_name):
        print(f"üîÑ Renaming '{old_name}' to '{new_name}'...")
        url = f"{self.base_url}/repos/{self.user}/{old_name}"
        data = {"name": new_name}
        response = requests.patch(url, json=data, headers=self.headers)
        
        if response.status_code == 200:
            print(f"‚úÖ Success! Repository renamed.")
            print(f"   Old Name: {old_name}")
            print(f"   New Name: {new_name}")
            print(f"   New URL: {response.json()['html_url']}")
        else:
            print(f"‚ùå Failed to rename: {response.json().get('message')}")

    def get_issues(self, repo_name):
        url = f"{self.base_url}/repos/{self.user}/{repo_name}/issues"
        params = {"state": "open"} 
        response = requests.get(url, headers=self.headers, params=params)
        
        if response.status_code == 200:
            issues = response.json()
            if not issues:
                print(f"‚úÖ No open issues found in '{repo_name}'.")
                return
            print(f"\nüêû Open Issues for '{repo_name}':")
            print("-" * 50)
            for issue in issues:
                if 'pull_request' in issue: continue
                print(f"#{issue['number']} - {issue['title']}")
                print(f"   Created by: {issue['user']['login']}")
                print(f"   Link: {issue['html_url']}\n")
        else:
            print(f"‚ùå Failed to fetch issues: {response.json().get('message')}")

    def pull_repo(self, repo_name, path="."):
        print(f"‚¨áÔ∏è  Pulling (Downloading) '{repo_name}'...")
        repo_info_url = f"{self.base_url}/repos/{self.user}/{repo_name}"
        repo_resp = requests.get(repo_info_url, headers=self.headers)
        if repo_resp.status_code != 200:
            print(f"‚ùå Repository not found.")
            return
        
        default_branch = repo_resp.json().get("default_branch", "main")
        zip_url = f"{self.base_url}/repos/{self.user}/{repo_name}/zipball/{default_branch}"
        response = requests.get(zip_url, headers=self.headers, stream=True)
        
        if response.status_code == 200:
            try:
                z = zipfile.ZipFile(io.BytesIO(response.content))
                print(f"üì¶ Extracting to '{path}'...")
                z.extractall(path)
                print(f"‚úÖ Repository '{repo_name}' pulled successfully!")
            except Exception as e:
                print(f"‚ùå Error extracting zip: {e}")
        else:
            print(f"‚ùå Failed to download: {response.status_code} {response.reason}")

    def create_repo(self, name, private=False, description=""):
        url = f"{self.base_url}/user/repos"
        data = {"name": name, "private": private, "description": description, "auto_init": True}
        response = requests.post(url, json=data, headers=self.headers)
        if response.status_code == 201:
            print(f"‚úÖ Repository '{name}' created successfully! (Private: {private})")
            print(f"   URL: {response.json()['html_url']}")
        else:
            print(f"‚ùå Failed to create repo: {response.json().get('message')}")

    def view_repo(self, name):
        url = f"{self.base_url}/repos/{self.user}/{name}"
        response = requests.get(url, headers=self.headers)
        if response.status_code == 200:
            repo = response.json()
            print(f"\nüì¶ Repository: {repo['name']}")
            print(f"   Description: {repo['description']}")
            print(f"   Private: {repo['private']}")
            print(f"   Stars: {repo['stargazers_count']}")
            print(f"   URL: {repo['html_url']}")
            print(f"   Clone: {repo['clone_url']}")
            print(f"   Open Issues: {repo['open_issues_count']}")
            print(f"   Default Branch: {repo['default_branch']}")
            print(f"   Last Updated: {repo['updated_at']}\n")
        else:
            print(f"‚ùå Repository not found or access denied.")

    def delete_repo(self, name):
        confirmation = input(f"‚ö†Ô∏è  Are you sure you want to DELETE '{self.user}/{name}'? This cannot be undone! (type 'yes'): ")
        if confirmation.lower() != 'yes':
            print("Operation cancelled.")
            return
        url = f"{self.base_url}/repos/{self.user}/{name}"
        response = requests.delete(url, headers=self.headers)
        if response.status_code == 204:
            print(f"üóëÔ∏è  Repository '{name}' deleted successfully.")
        else:
            print(f"‚ùå Failed to delete repo: {response.json().get('message')}")

    def set_visibility(self, name, private):
        url = f"{self.base_url}/repos/{self.user}/{name}"
        data = {"private": private}
        response = requests.patch(url, json=data, headers=self.headers)
        if response.status_code == 200:
            state = "Private" if private else "Public"
            print(f"üîí Repository '{name}' is now {state}.")
        else:
            print(f"‚ùå Failed to update visibility: {response.json().get('message')}")

    def get_file_sha(self, repo, path):
        url = f"{self.base_url}/repos/{self.user}/{repo}/contents/{path}"
        response = requests.get(url, headers=self.headers)
        if response.status_code == 200:
            return response.json()['sha']
        return None

    def upload_file(self, repo_name, local_path, target_path=None, commit_message=None):
        if not os.path.isfile(local_path):
            print(f"‚ùå Error: Local file '{local_path}' not found.")
            return

        filename = os.path.basename(local_path)
        remote_path = target_path if target_path else filename
        if target_path and not os.path.splitext(target_path)[1]: 
             remote_path = f"{target_path}/{filename}".replace("//", "/")

        try:
            with open(local_path, "rb") as f:
                content = base64.b64encode(f.read()).decode("utf-8")
        except Exception as e:
            print(f"‚ùå Error reading file: {e}")
            return

        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{remote_path}"
        sha = self.get_file_sha(repo_name, remote_path)
        message = f"Update {filename}" if sha else f"Create {filename}"
        if commit_message: message = commit_message
        
        data = {"message": message, "content": content}
        if sha: data["sha"] = sha

        response = requests.put(url, json=data, headers=self.headers)
        if response.status_code in [200, 201]:
            action = "Updated" if sha else "Uploaded"
            print(f"‚úÖ {action} '{local_path}' -> '{remote_path}'")
        else:
            print(f"‚ùå Failed to upload '{local_path}': {response.json().get('message')}")

    def upload_folder(self, repo_name, local_folder, target_folder="", commit_message=None):
        if not os.path.isdir(local_folder):
            print(f"‚ùå Error: Local directory '{local_folder}' not found.")
            return

        IGNORE_DIRS = {'.git', '__pycache__', 'venv', 'env', '.idea', '.vscode', 'node_modules'}
        IGNORE_FILES = {'.DS_Store'}

        print(f"üìÇ Starting upload of folder '{local_folder}'...")
        for root, dirs, files in os.walk(local_folder):
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
            for file in files:
                if file in IGNORE_FILES: continue
                local_file_path = os.path.join(root, file)
                if local_folder == ".": relative_path = os.path.relpath(local_file_path, local_folder)
                else: relative_path = os.path.relpath(local_file_path, local_folder)
                
                if target_folder: remote_path = os.path.join(target_folder, relative_path).replace("\\", "/")
                else: remote_path = relative_path.replace("\\", "/")
                if remote_path.startswith('/'): remote_path = remote_path[1:]

                self._upload_file_direct(repo_name, local_file_path, remote_path, commit_message)
        print("üèÅ Upload complete.")

    def _upload_file_direct(self, repo_name, local_path, remote_path, commit_message=None):
        try:
            with open(local_path, "rb") as f:
                content = base64.b64encode(f.read()).decode("utf-8")
        except Exception as e:
            print(f"‚ùå Error reading file: {e}")
            return
        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{remote_path}"
        sha = self.get_file_sha(repo_name, remote_path)
        filename = os.path.basename(local_path)
        message = f"Update {filename}" if sha else f"Create {filename}"
        if commit_message: message = commit_message
        data = {"message": message, "content": content}
        if sha: data["sha"] = sha
        response = requests.put(url, json=data, headers=self.headers)
        if response.status_code in [200, 201]:
            action = "Updated" if sha else "Uploaded"
            print(f"‚úÖ {action} '{local_path}' -> '{remote_path}'")
        else:
            print(f"‚ùå Failed to upload '{local_path}': {response.json().get('message')}")

    def get_repo_contents(self, repo_name, path=""):
        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{path}"
        response = requests.get(url, headers=self.headers)
        if response.status_code == 200: return response.json()
        return None

    def delete_path(self, repo_name, remote_path, commit_message=None):
        print(f"Attempting to delete: {remote_path} from {repo_name}")
        contents = self.get_repo_contents(repo_name, remote_path)
        if contents is None:
            print(f"‚ùå Path '{remote_path}' not found in repo '{repo_name}'.")
            return False
        if isinstance(contents, list): 
            print(f"üìÇ Deleting folder '{remote_path}' recursively...")
            for item in contents:
                item_path = item['path']
                if not self.delete_path(repo_name, item_path, commit_message): return False
            print(f"‚úÖ Folder '{remote_path}' and its contents deleted successfully.")
            return True
        else: return self.delete_file(repo_name, remote_path, commit_message)

    def delete_file(self, repo_name, remote_path, commit_message=None):
        sha = self.get_file_sha(repo_name, remote_path)
        if not sha: return False
        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{remote_path}"
        data = {"message": f"Delete {remote_path}", "sha": sha}
        response = requests.delete(url, json=data, headers=self.headers)
        if response.status_code == 200:
            print(f"üóëÔ∏è  File '{remote_path}' deleted successfully.")
            return True
        else:
            print(f"‚ùå Failed to delete file '{remote_path}': {response.json().get('message')}")
            return False

def save_token_globally(token):
    """Identifies the OS and saves the token permanently."""
    os_type = platform.system()
    
    # Update current session immediately
    os.environ["GITHUB_TOKEN"] = token
    print("üîë Setting up your token...")

    if os_type == "Windows":
        try:
            # Use setx for persistent storage on Windows
            subprocess.run(["setx", "GITHUB_TOKEN", token], check=True, shell=True, stdout=subprocess.DEVNULL)
            print("‚úÖ Token saved to Windows Environment Variables.")
        except Exception as e:
            print(f"‚ùå Failed to save token on Windows: {e}")

    else: # Linux, Darwin (macOS), or Termux (Android)
        shell = os.environ.get("SHELL", "/bin/bash")
        config_file = os.path.expanduser("~/.bashrc") # Default for Termux
        
        if "zsh" in shell:
            config_file = os.path.expanduser("~/.zshrc")
        elif "bash" in shell:
            config_file = os.path.expanduser("~/.bashrc")
        
        # Check if file exists, if not, try .profile
        if not os.path.exists(config_file):
            if os.path.exists(os.path.expanduser("~/.profile")):
                config_file = os.path.expanduser("~/.profile")
            else:
                # Fallback to .bashrc even if it doesn't exist, we will create it
                config_file = os.path.expanduser("~/.bashrc")

        try:
            with open(config_file, "a") as f:
                f.write(f'\nexport GITHUB_TOKEN="{token}"\n')
            print(f"‚úÖ Token appended to '{config_file}'.")
            print("‚ö†Ô∏è  IMPORTANT: Please restart your terminal or run:")
            print(f"   source {config_file}")
        except Exception as e:
            print(f"‚ùå Failed to save token to {config_file}: {e}")

def main():
    parser = argparse.ArgumentParser(description="GitHub CLI Manager", epilog=f"Version: {__version__}")
    parser.add_argument("--version", action="version", version=f"%(prog)s {__version__}")
    parser.add_argument("--token", help="GitHub Personal Access Token (Temporary)")
    
    # Global flag for setting token
    parser.add_argument("--set-token", help="Set the GITHUB_TOKEN permanently in your system", type=str)

    subparsers = parser.add_subparsers(dest="command", required=False)
    check_account_parser = parser.add_argument_group("Global Commands")
    check_account_parser.add_argument("--check-account", action="store_true", help="Show the connected GitHub account")

    # Command Definitions
    create_parser = subparsers.add_parser("create", help="Create a new repository")
    create_parser.add_argument("name", help="Name of the repository")
    create_parser.add_argument("--private", action="store_true", help="Make repository private")
    create_parser.add_argument("--desc", default="", help="Description of the repository")

    view_parser = subparsers.add_parser("view", help="View repository details")
    view_parser.add_argument("name", help="Name of the repository")

    rename_parser = subparsers.add_parser("rename", help="Rename a repository")
    rename_parser.add_argument("old_name", help="Current name")
    rename_parser.add_argument("new_name", help="New name")

    ls_parser = subparsers.add_parser("ls", help="List files/folders")
    ls_parser.add_argument("name", help="Repo name")
    ls_parser.add_argument("limit", nargs='?', default=100, type=int)
    ls_parser.add_argument("--fi", action="store_true")
    ls_parser.add_argument("--fo", action="store_true")
    ls_parser.add_argument("--path", default="")

    issues_parser = subparsers.add_parser("issues", help="Get open issues")
    issues_parser.add_argument("name", help="Repo name")

    pull_parser = subparsers.add_parser("pull", help="Download repo")
    pull_parser.add_argument("name", help="Repo name")
    pull_parser.add_argument("--dest", default=".")

    delete_parser = subparsers.add_parser("delete", help="Delete repo")
    delete_parser.add_argument("name", help="Repo name")

    vis_parser = subparsers.add_parser("visibility", help="Change visibility")
    vis_parser.add_argument("name", help="Repo name")
    vis_parser.add_argument("--public", action="store_true")
    vis_parser.add_argument("--private", action="store_true")

    upload_parser = subparsers.add_parser("upload", help="Upload files")
    upload_parser.add_argument("repo", help="Target repo")
    upload_parser.add_argument("path", default=".", nargs="?")
    upload_parser.add_argument("-m", "--message")
    upload_parser.add_argument("--target")

    rm_parser = subparsers.add_parser("rm", help="Delete file/folder")
    rm_parser.add_argument("repo", help="Target repo")
    rm_parser.add_argument("path", help="Path to delete")

    args = parser.parse_args()

    # --- HANDLE TOKEN SETUP ---
    if args.set_token:
        save_token_globally(args.set_token)
        # Use the new token immediately for verification
        token = args.set_token
    else:
        # Load normally
        token = args.token or os.environ.get("GITHUB_TOKEN")

    if not token:
        print("‚ùå Error: GitHub Token is required. Use --set-token to save it once, or --token for temp access.")
        sys.exit(1)

    gh = GitHubManager(token)

    # If setting token or checking account, show user
    if args.check_account or args.set_token:
        print(f"‚úÖ Connected as: {gh.user}")
        return

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    # Execution logic
    if args.command == "create": gh.create_repo(args.name, args.private, args.desc)
    elif args.command == "view": gh.view_repo(args.name)
    elif args.command == "rename": gh.rename_repo(args.old_name, args.new_name)
    elif args.command == "ls":
        mode = "all"
        if args.fi: mode = "fi"
        elif args.fo: mode = "fo"
        gh.list_contents(args.name, args.limit, mode, args.path)
    elif args.command == "issues": gh.get_issues(args.name)
    elif args.command == "pull": gh.pull_repo(args.name, args.dest)
    elif args.command == "delete": gh.delete_repo(args.name)
    elif args.command == "visibility":
        if args.public and args.private: print("‚ùå Error: Cannot set both flags.")
        elif args.public: gh.set_visibility(args.name, False)
        elif args.private: gh.set_visibility(args.name, True)
    elif args.command == "upload":
        target = getattr(args, 'target', '')
        if args.path == ".": gh.upload_folder(args.repo, ".", target, args.message)
        elif os.path.isfile(args.path): gh.upload_file(args.repo, args.path, target, args.message)
        elif os.path.isdir(args.path): gh.upload_folder(args.repo, args.path, target, args.message)
        else: print(f"‚ùå Error: Path '{args.path}' not found.")
    elif args.command == "rm": gh.delete_path(args.repo, args.path)

if __name__ == "__main__":
    main()

