#!/usr/bin/env python3
import argparse
import os
import sys
import base64
import requests
import zipfile
import io
import time
from typing import Optional, Tuple, List, Dict

__version__ = "2.1.0"

class Colors:
    """ANSI color codes for terminal output"""
    GREEN = '\033[92m'
    RED = '\033[91m'
    YELLOW = '\033[93m'
    BLUE = '\033[94m'
    MAGENTA = '\033[95m'
    CYAN = '\033[96m'
    RESET = '\033[0m'
    BOLD = '\033[1m'
    DIM = '\033[2m'

def print_success(msg):
    print(f"{Colors.GREEN}âœ“{Colors.RESET} {msg}")

def print_error(msg):
    print(f"{Colors.RED}âœ—{Colors.RESET} {msg}")

def print_info(msg):
    print(f"{Colors.BLUE}â„¹{Colors.RESET} {msg}")

def print_warning(msg):
    print(f"{Colors.YELLOW}âš {Colors.RESET} {msg}")

class GitHubManager:
    """Enhanced GitHub repository manager with advanced features"""
    
    def __init__(self, token: str):
        self.token = token
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json"
        }
        self.user = self._get_current_user()

    def _get_current_user(self) -> str:
        """Get the currently authenticated GitHub user"""
        try:
            response = self._make_request('GET', f"{self.base_url}/user", timeout=10)
            if response.status_code == 200:
                return response.json()['login']
            elif response.status_code == 401:
                print_error("Invalid GitHub token. Please check your token and try again.")
                print_info("Create a token at: https://github.com/settings/tokens")
            else:
                print_error(f"Failed to authenticate: {response.status_code}")
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")
        sys.exit(1)

    def _make_request(self, method: str, url: str, max_retries: int = 3, **kwargs) -> requests.Response:
        """Make HTTP request with retry logic"""
        for attempt in range(max_retries):
            try:
                response = requests.request(method, url, headers=self.headers, **kwargs)
                return response
            except requests.exceptions.RequestException as e:
                if attempt < max_retries - 1:
                    wait_time = 2 ** attempt  # Exponential backoff
                    print_warning(f"Request failed, retrying in {wait_time}s... ({attempt + 1}/{max_retries})")
                    time.sleep(wait_time)
                else:
                    raise

    def _parse_repo(self, repo_input: str) -> Tuple[str, str]:
        """Parse repository input (accepts 'owner/repo' or just 'repo')"""
        if "/" in repo_input:
            parts = repo_input.split("/", 1)
            return parts[0], parts[1]
        return self.user, repo_input

    def _clean_path(self, path: str) -> str:
        """Normalize file paths for GitHub API"""
        if not path:
            return ""
        clean = path.replace("\\", "/").lstrip("/")
        return clean

    def _repo_exists(self, owner: str, repo: str) -> bool:
        """Check if a repository exists and is accessible"""
        try:
            response = self._make_request('GET', f"{self.base_url}/repos/{owner}/{repo}", timeout=10)
            return response.status_code == 200
        except requests.exceptions.RequestException:
            return False

    def list_repositories(self, visibility: str = "all", sort: str = "updated", limit: int = 30):
        """List all repositories for the authenticated user"""
        print_info(f"Fetching your repositories ({visibility})...")
        
        try:
            params = {"visibility": visibility, "sort": sort, "per_page": limit}
            response = self._make_request('GET', f"{self.base_url}/user/repos", params=params, timeout=10)
            
            if response.status_code != 200:
                print_error(f"Failed to fetch repositories: {response.json().get('message', 'Unknown error')}")
                return

            repos = response.json()
            
            if not repos:
                print_info("No repositories found")
                return

            print(f"\n{Colors.BOLD}ðŸ“š Your Repositories ({len(repos)}){Colors.RESET}")
            print("â”€" * 80)
            
            for repo in repos:
                visibility_icon = "ðŸ”’" if repo['private'] else "ðŸŒ"
                stars = f"â­{repo['stargazers_count']}" if repo['stargazers_count'] > 0 else ""
                language = f"[{repo['language']}]" if repo['language'] else ""
                
                print(f"{visibility_icon} {Colors.BOLD}{repo['name']}{Colors.RESET} {language} {stars}")
                if repo['description']:
                    print(f"   {Colors.DIM}{repo['description'][:70]}{Colors.RESET}")
                print(f"   {Colors.CYAN}{repo['html_url']}{Colors.RESET}")
                print()
            
            print("â”€" * 80)
            
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def read_file(self, repo_input: str, file_path: str, show_raw: bool = False):
        """Read and display file contents from repository"""
        owner, repo = self._parse_repo(repo_input)
        file_path = self._clean_path(file_path)
        
        print_info(f"Reading '{file_path}' from {owner}/{repo}...")
        
        try:
            response = self._make_request(
                'GET',
                f"{self.base_url}/repos/{owner}/{repo}/contents/{file_path}",
                timeout=10
            )
            
            if response.status_code != 200:
                print_error(f"File not found or access denied")
                return

            data = response.json()
            
            if isinstance(data, list):
                print_error(f"'{file_path}' is a directory, not a file")
                return
            
            if 'content' not in data:
                print_error("Unable to read file content")
                return
            
            # Decode base64 content
            content = base64.b64decode(data['content']).decode('utf-8')
            
            if show_raw:
                print(content)
            else:
                print(f"\n{Colors.BOLD}ðŸ“„ {file_path}{Colors.RESET}")
                print(f"{Colors.DIM}Size: {data['size']} bytes | SHA: {data['sha'][:7]}{Colors.RESET}")
                print("â”€" * 80)
                print(content)
                print("â”€" * 80 + "\n")
                
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")
        except Exception as e:
            print_error(f"Error reading file: {e}")

    def rename_repository(self, old_name: str, new_name: str):
        """Rename a repository"""
        owner, repo = self._parse_repo(old_name)
        
        print_info(f"Renaming '{repo}' to '{new_name}'...")
        
        try:
            response = self._make_request(
                'PATCH',
                f"{self.base_url}/repos/{owner}/{repo}",
                json={"name": new_name},
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                print_success(f"Repository renamed successfully!")
                print_info(f"New URL: {data['html_url']}")
            else:
                error_msg = response.json().get('message', 'Unknown error')
                print_error(f"Failed to rename repository: {error_msg}")
                
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def update_repository(self, repo_input: str, description: str = None, 
                         private: bool = None, homepage: str = None):
        """Update repository settings"""
        owner, repo = self._parse_repo(repo_input)
        
        updates = {}
        if description is not None:
            updates['description'] = description
        if private is not None:
            updates['private'] = private
        if homepage is not None:
            updates['homepage'] = homepage
        
        if not updates:
            print_warning("No updates specified")
            return
        
        print_info(f"Updating repository '{owner}/{repo}'...")
        
        try:
            response = self._make_request(
                'PATCH',
                f"{self.base_url}/repos/{owner}/{repo}",
                json=updates,
                timeout=10
            )
            
            if response.status_code == 200:
                print_success("Repository updated successfully!")
                if description:
                    print_info(f"Description: {description}")
                if private is not None:
                    print_info(f"Visibility: {'Private' if private else 'Public'}")
                if homepage:
                    print_info(f"Homepage: {homepage}")
            else:
                error_msg = response.json().get('message', 'Unknown error')
                print_error(f"Failed to update repository: {error_msg}")
                
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def list_branches(self, repo_input: str):
        """List all branches in a repository"""
        owner, repo = self._parse_repo(repo_input)
        
        print_info(f"Fetching branches for '{owner}/{repo}'...")
        
        try:
            response = self._make_request(
                'GET',
                f"{self.base_url}/repos/{owner}/{repo}/branches",
                timeout=10
            )
            
            if response.status_code != 200:
                print_error(f"Failed to fetch branches: {response.json().get('message', 'Unknown error')}")
                return

            branches = response.json()
            
            if not branches:
                print_info("No branches found")
                return

        
            repo_response = self._make_request(
                'GET',
                f"{self.base_url}/repos/{owner}/{repo}",
                timeout=10
            )
            default_branch = repo_response.json().get('default_branch', 'main') if repo_response.status_code == 200 else 'main'

            print(f"\n{Colors.BOLD}ðŸŒ² Branches for {owner}/{repo}{Colors.RESET}")
            print("â”€" * 60)
            
            for branch in branches:
                is_default = branch['name'] == default_branch
                prefix = f"{Colors.GREEN}âžœ{Colors.RESET}" if is_default else " "
                default_tag = f"{Colors.YELLOW}(default){Colors.RESET}" if is_default else ""
                print(f"{prefix} {branch['name']} {default_tag}")
            
            print("â”€" * 60)
            print(f"Total: {len(branches)} branch(es)\n")
            
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def repo_stats(self, repo_input: str):
        """Show detailed repository statistics"""
        owner, repo = self._parse_repo(repo_input)
        
        print_info(f"Fetching statistics for '{owner}/{repo}'...")
        
        try:
            response = self._make_request('GET', f"{self.base_url}/repos/{owner}/{repo}", timeout=10)
            
            if response.status_code != 200:
                print_error("Repository not found or access denied")
                return

            data = response.json()
            
            # Calculate repository size in MB
            size_mb = data['size'] / 1024
            
            print(f"\n{Colors.BOLD}ðŸ“Š Statistics for {data['full_name']}{Colors.RESET}")
            print("â”€" * 70)
            print(f"  {Colors.BOLD}General:{Colors.RESET}")
            print(f"    Description:  {data['description'] or 'No description'}")
            print(f"    Visibility:   {'ðŸ”’ Private' if data['private'] else 'ðŸŒ Public'}")
            print(f"    Created:      {data['created_at'][:10]}")
            print(f"    Updated:      {data['updated_at'][:10]}")
            print(f"    Size:         {size_mb:.2f} MB")
            print(f"    Language:     {data['language'] or 'N/A'}")
            
            print(f"\n  {Colors.BOLD}Engagement:{Colors.RESET}")
            print(f"    â­ Stars:      {data['stargazers_count']}")
            print(f"    ðŸ‘  Watchers:   {data['watchers_count']}")
            print(f"    ðŸ”± Forks:      {data['forks_count']}")
            print(f"    âš   Issues:     {data['open_issues_count']}")
            
            print(f"\n  {Colors.BOLD}Branches:{Colors.RESET}")
            print(f"    Default:      {data['default_branch']}")
            
            if data['homepage']:
                print(f"\n  {Colors.BOLD}Links:{Colors.RESET}")
                print(f"    Homepage:     {data['homepage']}")
            
            print(f"\n  {Colors.BOLD}URLs:{Colors.RESET}")
            print(f"    Web:          {data['html_url']}")
            print(f"    Clone:        {data['clone_url']}")
            print("â”€" * 70 + "\n")
            
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def list_files(self, repo_input: str, path: str = "", limit: int = 100, 
                   files_only: bool = False, folders_only: bool = False):
        """List repository contents with smart formatting"""
        owner, repo = self._parse_repo(repo_input)
        path = self._clean_path(path)
        
        print_info(f"Listing contents of '{owner}/{repo}/{path}'...")
        
        try:
            response = self._make_request(
                'GET',
                f"{self.base_url}/repos/{owner}/{repo}/contents/{path}",
                timeout=10
            )
            
            if response.status_code != 200:
                print_error(f"Failed to list contents: {response.json().get('message', 'Unknown error')}")
                return

            items = response.json()
            if not isinstance(items, list):
                items = [items]

            # Sort: folders first, then alphabetically
            items.sort(key=lambda x: (x['type'] != 'dir', x['name'].lower()))

            print(f"\n{Colors.BOLD}ðŸ“‚ {owner}/{repo}/{path}{Colors.RESET}")
            print("â”€" * 60)
            
            count = 0
            for item in items[:limit]:
                item_type = item['type']
                name = item['name']
                
                # Apply filters
                if files_only and item_type != "file":
                    continue
                if folders_only and item_type != "dir":
                    continue
                
                icon = "ðŸ“" if item_type == "dir" else "ðŸ“„"
                suffix = "/" if item_type == "dir" else ""
                print(f"  {icon} {name}{suffix}")
                count += 1
            
            if count == 0:
                print("  (No items found)")
            print("â”€" * 60 + "\n")
            
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def create_repository(self, name: str, private: bool = False, description: str = ""):
        """Create a new GitHub repository"""
        print_info(f"Creating repository '{name}'...")
        
        data = {
            "name": name,
            "private": private,
            "description": description,
            "auto_init": True
        }
        
        try:
            response = self._make_request(
                'POST',
                f"{self.base_url}/user/repos",
                json=data,
                timeout=10
            )
            
            if response.status_code == 201:
                repo_data = response.json()
                print_success(f"Repository '{name}' created!")
                print_info(f"URL: {repo_data['html_url']}")
                print_info(f"Clone: git clone {repo_data['clone_url']}")
            else:
                error_msg = response.json().get('message', 'Unknown error')
                print_error(f"Failed to create repository: {error_msg}")
                
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def show_repository(self, repo_input: str):
        """Display repository information"""
        owner, repo = self._parse_repo(repo_input)
        
        try:
            response = self._make_request('GET', f"{self.base_url}/repos/{owner}/{repo}", timeout=10)
            
            if response.status_code != 200:
                print_error("Repository not found or access denied")
                return

            data = response.json()
            print(f"\n{Colors.BOLD}ðŸ“¦ {data['full_name']}{Colors.RESET}")
            print("â”€" * 60)
            print(f"  Description:  {data['description'] or 'No description'}")
            print(f"  Visibility:   {'ðŸ”’ Private' if data['private'] else 'ðŸŒ Public'}")
            print(f"  Stars:        â­ {data['stargazers_count']}")
            print(f"  Forks:        ðŸ”± {data['forks_count']}")
            print(f"  Language:     {data['language'] or 'N/A'}")
            print(f"  URL:          {data['html_url']}")
            print(f"  Clone:        git clone {data['clone_url']}")
            print("â”€" * 60 + "\n")
            
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def delete_repository(self, repo_input: str, force: bool = False):
        """Delete a GitHub repository"""
        owner, repo = self._parse_repo(repo_input)
        
        if not force:
            print_warning(f"You are about to DELETE '{owner}/{repo}' permanently!")
            confirm = input("Type the repository name to confirm: ").strip()
            if confirm != repo:
                print_info("Deletion cancelled")
                return
        
        try:
            response = self._make_request('DELETE', f"{self.base_url}/repos/{owner}/{repo}", timeout=10)
            
            if response.status_code == 204:
                print_success(f"Repository '{repo}' deleted")
            else:
                error_msg = response.json().get('message', 'Unknown error')
                print_error(f"Failed to delete repository: {error_msg}")
                
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")

    def _get_file_sha(self, owner: str, repo: str, path: str) -> Optional[str]:
        """Get the SHA hash of a file (needed for updates)"""
        path = self._clean_path(path)
        try:
            response = self._make_request(
                'GET',
                f"{self.base_url}/repos/{owner}/{repo}/contents/{path}",
                timeout=10
            )
            if response.status_code == 200:
                data = response.json()
            
                if isinstance(data, dict) and 'sha' in data:
                    return data['sha']
        except requests.exceptions.RequestException:
            pass
        return None

    def upload_file(self, repo_input: str, local_path: str, 
                   remote_path: Optional[str] = None, message: Optional[str] = None):
        """Upload a single file to repository"""
        owner, repo = self._parse_repo(repo_input)
        
        if not self._repo_exists(owner, repo):
            print_error(f"Repository '{owner}/{repo}' not found")
            return
        
        if not os.path.isfile(local_path):
            print_error(f"Local file '{local_path}' not found")
            return
        
        filename = os.path.basename(local_path)
        target = remote_path if remote_path else filename
        

        if remote_path and not os.path.splitext(remote_path)[1]:
            target = f"{remote_path}/{filename}"
        
        self._upload_single_file(owner, repo, local_path, target, message)

    def upload_folder(self, repo_input: str, local_folder: str, 
                     remote_folder: str = "", message: Optional[str] = None):
        """Upload entire folder to repository"""
        owner, repo = self._parse_repo(repo_input)
        
        if not self._repo_exists(owner, repo):
            print_error(f"Repository '{owner}/{repo}' not found")
            return
        
        if not os.path.isdir(local_folder):
            print_error(f"Local folder '{local_folder}' not found")
            return
        
        print_info(f"Uploading folder '{local_folder}' to {owner}/{repo}...")
        
        
        IGNORE = {'.git', '__pycache__', 'venv', 'env', '.idea', 
                  '.vscode', 'node_modules', '.DS_Store', '.gitignore'}
        
        uploaded = 0
        failed = 0
        
        for root, dirs, files in os.walk(local_folder):
            
            dirs[:] = [d for d in dirs if d not in IGNORE]
            
            for file in files:
                if file in IGNORE:
                    continue
                    
                local_file = os.path.join(root, file)
                relative = os.path.relpath(local_file, local_folder)
                remote = os.path.join(remote_folder, relative) if remote_folder else relative
                
                success = self._upload_single_file(owner, repo, local_file, remote, message)
                if success:
                    uploaded += 1
                else:
                    failed += 1
        
        if failed > 0:
            print_warning(f"Upload complete! ({uploaded} succeeded, {failed} failed)")
        else:
            print_success(f"Upload complete! ({uploaded} files)")

    def _upload_single_file(self, owner: str, repo: str, local_path: str,
                           remote_path: str, message: Optional[str]) -> bool:
        """Internal method to upload a single file"""
        remote_path = self._clean_path(remote_path)
        
        try:
        
            file_size = os.path.getsize(local_path)
            if file_size > 100 * 1024 * 1024:  # 100MB
                print_error(f"File too large (>100MB): {local_path}")
                return False
            
            with open(local_path, "rb") as f:
                content = base64.b64encode(f.read()).decode("utf-8")
        except Exception as e:
            print_error(f"Failed to read '{local_path}': {e}")
            return False
        
        sha = self._get_file_sha(owner, repo, remote_path)
        filename = os.path.basename(local_path)
        
        commit_msg = message if message else (
            f"Update {filename}" if sha else f"Add {filename}"
        )
        
        data = {"message": commit_msg, "content": content}
        if sha:
            data["sha"] = sha
        
        try:
            response = self._make_request(
                'PUT',
                f"{self.base_url}/repos/{owner}/{repo}/contents/{remote_path}",
                json=data,
                timeout=30
            )
            
            if response.status_code in [200, 201]:
                action = "Updated" if sha else "Added"
                print_success(f"{action}: {remote_path}")
                return True
            else:
                error_msg = response.json().get('message', 'Unknown error')
                print_error(f"Failed to upload '{filename}': {error_msg}")
                return False
                
        except requests.exceptions.RequestException as e:
            print_error(f"Upload error: {e}")
            return False

    def delete_path(self, repo_input: str, remote_path: str, 
                   message: Optional[str] = None, force: bool = False):
        """Delete a file or folder from repository"""
        owner, repo = self._parse_repo(repo_input)
        remote_path = self._clean_path(remote_path)
        
        if not self._repo_exists(owner, repo):
            print_error(f"Repository '{owner}/{repo}' not found")
            return False
        
        if not force:
            print_warning(f"Delete '{remote_path}' from {owner}/{repo}?")
            confirm = input("Type 'yes' to confirm: ").strip().lower()
            if confirm != 'yes':
                print_info("Deletion cancelled")
                return False
        
        print_info(f"Deleting '{remote_path}'...")
        
        
        sha = self._get_file_sha(owner, repo, remote_path)
        if sha:
            return self._delete_file(owner, repo, remote_path, sha, message)
        
    
        try:
            response = self._make_request(
                'GET',
                f"{self.base_url}/repos/{owner}/{repo}/contents/{remote_path}",
                timeout=10
            )
            
            if response.status_code == 200:
                contents = response.json()
                if isinstance(contents, list):
                    print_info("Deleting folder recursively...")
                    deleted_count = 0
                    for item in contents:
                        # Validate item structure
                        if isinstance(item, dict) and 'path' in item:
                            self.delete_path(repo_input, item['path'], message, force=True)
                            deleted_count += 1
                        else:
                            print_warning(f"Skipping invalid item: {item}")
                    
                    if deleted_count > 0:
                        print_success(f"Folder '{remote_path}' deleted ({deleted_count} items)")
                    else:
                        print_info(f"Folder '{remote_path}' was empty")
                    return True
        except requests.exceptions.RequestException as e:
            print_error(f"Connection error: {e}")
            return False
        except (KeyError, TypeError) as e:
            print_error(f"Invalid response format: {e}")
            return False
        
        print_error(f"Path '{remote_path}' not found")
        return False

    def _delete_file(self, owner: str, repo: str, path: str, 
                    sha: str, message: Optional[str]) -> bool:
        """Internal method to delete a single file"""
        commit_msg = message if message else f"Delete {os.path.basename(path)}"
        data = {"message": commit_msg, "sha": sha}
        
        try:
            response = self._make_request(
                'DELETE',
                f"{self.base_url}/repos/{owner}/{repo}/contents/{path}",
                json=data,
                timeout=10
            )
            
            if response.status_code == 200:
                print_success(f"Deleted: {path}")
                return True
            else:
                error_msg = response.json().get('message', 'Unknown error')
                print_error(f"Failed to delete: {error_msg}")
                return False
                
        except requests.exceptions.RequestException as e:
            print_error(f"Delete error: {e}")
            return False

    def download_repo(self, repo_input: str, destination: str = ".", branch: str = "main"):
        """Download and extract a repository"""
        owner, repo = self._parse_repo(repo_input)
        
        print_info(f"Downloading '{owner}/{repo}' (branch: {branch})...")
        
        try:
            response = self._make_request(
                'GET',
                f"{self.base_url}/repos/{owner}/{repo}/zipball/{branch}",
                stream=True,
                timeout=30
            )
            
            if response.status_code == 404:
        
                print_warning(f"Branch '{branch}' not found, trying 'master'...")
                response = self._make_request(
                    'GET',
                    f"{self.base_url}/repos/{owner}/{repo}/zipball/master",
                    stream=True,
                    timeout=30
                )
            
            if response.status_code != 200:
                print_error(f"Failed to download repository: Status {response.status_code}")
                return
            
        
            z = zipfile.ZipFile(io.BytesIO(response.content))
            
            # GitHub zips have a top-level directory, so we extract without it
            for member in z.infolist():
                parts = member.filename.split('/', 1)
                if len(parts) > 1:
                    member.filename = parts[1]
                    if member.filename:  
                        z.extract(member, path=destination)
            
            dest_abs = os.path.abspath(destination)
            print_success(f"Downloaded to: {dest_abs}")
            
        except requests.exceptions.RequestException as e:
            print_error(f"Download error: {e}")
        except zipfile.BadZipFile:
            print_error("Failed to extract: Invalid ZIP file")


def setup_token(token: str, scope: str = "user"):
    """Set GitHub token as environment variable (Windows only)"""
    try:
        import winreg
        
        if scope == "system":
            key = winreg.CreateKey(
                winreg.HKEY_LOCAL_MACHINE,
                r'SYSTEM\CurrentControlSet\Control\Session Manager\Environment'
            )
            print_warning("System-level requires admin privileges and system restart")
        else:
            key = winreg.CreateKey(winreg.HKEY_CURRENT_USER, 'Environment')
        
        winreg.SetValueEx(key, "GITHUB_TOKEN", 0, winreg.REG_SZ, token)
        winreg.CloseKey(key)
        
        print_success(f"Token saved to {scope} environment")
        print_info("Restart your terminal to apply changes")
        
    except ImportError:
        print_error("This feature is Windows-only")
        print_info("Set GITHUB_TOKEN manually in your system environment")
    except Exception as e:
        print_error(f"Failed to set token: {e}")


def show_examples():
    """Show usage examples"""
    examples = f"""
{Colors.BOLD}Sora - GitHub Repository Manager{Colors.RESET}
{Colors.BOLD}Usage Examples:{Colors.RESET}

{Colors.BLUE}Authentication:{Colors.RESET}
  sora --token YOUR_TOKEN --check-account          Check current user
  sora --set-token YOUR_TOKEN                      Save token (Windows)

{Colors.BLUE}Repository Management:{Colors.RESET}
  sora repos                                       List all your repos
  sora repos --visibility public                   List only public repos
  sora create my-project                           Create new repo
  sora create my-app --private --desc "My app"     Create private repo
  sora view my-repo                                Show repo info
  sora stats my-repo                               Show detailed stats
  sora rename old-name new-name                    Rename repository
  sora update my-repo --desc "New description"     Update repo settings
  sora delete old-repo                             Delete repo

{Colors.BLUE}Branch Management:{Colors.RESET}
  sora branches my-repo                            List all branches

{Colors.BLUE}File Operations:{Colors.RESET}
  sora ls my-repo                                  List files
  sora ls my-repo --path src                       List files in folder
  sora ls my-repo --files-only                     Show only files
  sora cat my-repo README.md                       Read file contents
  sora cat my-repo src/app.py --raw              Raw output (no formatting)

{Colors.BLUE}Upload/Download:{Colors.RESET}
  sora push my-repo ./file.txt                     Upload file
  sora push my-repo ./folder                       Upload folder
  sora push my-repo ./app.py --target src/         Upload to specific path
  sora pull my-repo                                Download repo
  sora pull owner/repo --dest ./downloads          Download to folder

{Colors.BLUE}Delete Files:{Colors.RESET}
  sora rm my-repo path/to/file.txt                 Delete file
  sora rm my-repo old-folder --force               Delete folder (no confirm)

{Colors.BLUE}Options:{Colors.RESET}
  -m "message"    Custom commit message
  --force         Skip confirmation prompts
  --branch NAME   Specify branch (default: main)

{Colors.BLUE}Environment:{Colors.RESET}
  Set GITHUB_TOKEN environment variable to avoid --token flag
  Create token at: https://github.com/settings/tokens
"""
    print(examples)


def main():
    parser = argparse.ArgumentParser(
        description="Sora - Enhanced GitHub Repository Manager",
        epilog=f"Version {__version__} | Use 'sora --examples' for usage examples",
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    # Global options
    parser.add_argument("--version", action="version", version=f"Sora {__version__}")
    parser.add_argument("--token", help="GitHub Personal Access Token")
    parser.add_argument("--check-account", action="store_true", help="Show connected GitHub account")
    parser.add_argument("--set-token", help="Save token as environment variable (Windows)")
    parser.add_argument("--scope", choices=["user", "system"], default="user", help="Token scope (default: user)")
    parser.add_argument("--examples", action="store_true", help="Show usage examples")
    
    # Subcommands
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # List repositories
    repos = subparsers.add_parser("repos", aliases=["list"], help="List all repositories")
    repos.add_argument("--visibility", choices=["all", "public", "private"], default="all", help="Filter by visibility")
    repos.add_argument("--sort", choices=["created", "updated", "pushed", "full_name"], default="updated", help="Sort order")
    repos.add_argument("--limit", type=int, default=30, help="Max repositories to show")
    
    # Read file
    cat = subparsers.add_parser("cat", aliases=["read"], help="Read file contents")
    cat.add_argument("name", help="Repository name")
    cat.add_argument("file", help="File path to read")
    cat.add_argument("--raw", action="store_true", help="Show raw output without formatting")
    
    # Rename repository
    rename = subparsers.add_parser("rename", aliases=["mv"], help="Rename repository")
    rename.add_argument("old_name", help="Current repository name")
    rename.add_argument("new_name", help="New repository name")
    
    # Update repository
    update = subparsers.add_parser("update", help="Update repository settings")
    update.add_argument("name", help="Repository name")
    update.add_argument("--desc", help="New description")
    update.add_argument("--private", action="store_true", help="Make repository private")
    update.add_argument("--public", action="store_true", help="Make repository public")
    update.add_argument("--homepage", help="Set homepage URL")
    
    # List branches
    branches = subparsers.add_parser("branches", help="List repository branches")
    branches.add_argument("name", help="Repository name")
    
    # Repository stats
    stats = subparsers.add_parser("stats", aliases=["info"], help="Show detailed repository statistics")
    stats.add_argument("name", help="Repository name")
    
    # Create repository
    create = subparsers.add_parser("create", help="Create new repository")
    create.add_argument("name", help="Repository name")
    create.add_argument("--private", action="store_true", help="Make repository private")
    create.add_argument("--desc", default="", help="Repository description")
    
    # View repository
    view = subparsers.add_parser("view", help="Show repository information")
    view.add_argument("name", help="Repository name (owner/repo or repo)")
    
    # List files
    ls = subparsers.add_parser("ls", help="List repository contents")
    ls.add_argument("name", help="Repository name")
    ls.add_argument("--path", default="", help="Path to list")
    ls.add_argument("--limit", type=int, default=100, help="Max items to show")
    ls.add_argument("--files-only", action="store_true", help="Show only files")
    ls.add_argument("--folders-only", action="store_true", help="Show only folders")
    
    # Upload (push)
    push = subparsers.add_parser("push", aliases=["upload"], help="Upload file or folder")
    push.add_argument("repo", help="Repository name")
    push.add_argument("path", default=".", nargs="?", help="Local path to upload")
    push.add_argument("--target", help="Remote target path")
    push.add_argument("-m", "--message", help="Commit message")
    
    # Remove
    rm = subparsers.add_parser("rm", aliases=["remove", "del"], help="Delete file or folder")
    rm.add_argument("repo", help="Repository name")
    rm.add_argument("path", help="Remote path to delete")
    rm.add_argument("-m", "--message", help="Commit message")
    rm.add_argument("--force", action="store_true", help="Skip confirmation")
    
    # Delete repository
    delete = subparsers.add_parser("delete", help="Delete repository")
    delete.add_argument("name", help="Repository name")
    delete.add_argument("--force", action="store_true", help="Skip confirmation")
    
    # Download (pull)
    pull = subparsers.add_parser("pull", aliases=["download", "clone"], help="Download repository")
    pull.add_argument("name", help="Repository name (owner/repo or repo)")
    pull.add_argument("--dest", default=".", help="Destination folder")
    pull.add_argument("--branch", default="main", help="Branch name (default: main)")
    
    args = parser.parse_args()
    
    # Show examples
    if args.examples:
        show_examples()
        return
    
    # Set token
    if args.set_token:
        setup_token(args.set_token, args.scope)
        return
    
    # Get token
    token = args.token or os.environ.get("GITHUB_TOKEN")
    if not token:
        print_error("GitHub token required!")
        print_info("Use: sora --token YOUR_TOKEN")
        print_info("Or set GITHUB_TOKEN environment variable")
        print_info("Create token at: https://github.com/settings/tokens")
        sys.exit(1)
    
    # Initialize manager
    try:
        gh = GitHubManager(token)
    except SystemExit:
        sys.exit(1)
    
    # Check account
    if args.check_account:
        print_success(f"Connected as: {gh.user}")
        return
    
    # Handle commands
    if not args.command:
        parser.print_help()
        print(f"\n{Colors.BLUE}Tip:{Colors.RESET} Use 'sora --examples' for usage examples")
        return
    
    try:
        if args.command in ["repos", "list"]:
            gh.list_repositories(args.visibility, args.sort, args.limit)
        
        elif args.command in ["cat", "read"]:
            gh.read_file(args.name, args.file, args.raw)
        
        elif args.command in ["rename", "mv"]:
            gh.rename_repository(args.old_name, args.new_name)
        
        elif args.command == "update":
            private = True if args.private else (False if args.public else None)
            gh.update_repository(args.name, args.desc, private, args.homepage)
        
        elif args.command == "branches":
            gh.list_branches(args.name)
        
        elif args.command in ["stats", "info"]:
            gh.repo_stats(args.name)
        
        elif args.command == "create":
            gh.create_repository(args.name, args.private, args.desc)
        
        elif args.command == "view":
            gh.show_repository(args.name)
        
        elif args.command == "ls":
            gh.list_files(
                args.name, 
                args.path, 
                args.limit,
                args.files_only,
                args.folders_only
            )
        
        elif args.command in ["push", "upload"]:
            if os.path.isdir(args.path):
                gh.upload_folder(args.repo, args.path, args.target or "", args.message)
            else:
                gh.upload_file(args.repo, args.path, args.target, args.message)
        
        elif args.command in ["rm", "remove", "del"]:
            gh.delete_path(args.repo, args.path, args.message, args.force)
        
        elif args.command == "delete":
            gh.delete_repository(args.name, args.force)
        
        elif args.command in ["pull", "download", "clone"]:
            gh.download_repo(args.name, args.dest, args.branch)
    
    except KeyboardInterrupt:
        print_info("\nOperation cancelled by user")
        sys.exit(0)
    except Exception as e:
        import traceback
        print_error(f"Unexpected error: {e}")
        print(f"\n{Colors.YELLOW}Debug traceback:{Colors.RESET}")
        traceback.print_exc()
        sys.exit(1)


if __name__ == "__main__":

    main()
