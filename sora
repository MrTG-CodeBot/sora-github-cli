#!/usr/bin/env python3
import argparse
import os
import sys
import base64
import requests
import zipfile
import io

__version__ = "1.3.0"

class GitHubManager:
    def __init__(self, token):
        self.token = token
        self.base_url = "https://api.github.com"
        self.headers = {
            "Authorization": f"token {token}",
            "Accept": "application/vnd.github.v3+json"
        }
        self.user = self.get_current_user()

    def get_current_user(self):
        """Fetches the authenticated user's username."""
        url = f"{self.base_url}/user"
        response = requests.get(url, headers=self.headers)
        if response.status_code == 200:
            return response.json()['login']
        else:
            print(f"Error: Invalid token or connection issue. {response.status_code}")
            sys.exit(1)

    # --- NEW FEATURE: List Files/Folders (ls) ---
    def list_contents(self, repo_name, limit=100, mode="all", path=""):
        """Lists files and folders in the repo."""
        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{path}"
        response = requests.get(url, headers=self.headers)

        if response.status_code == 200:
            items = response.json()
            
            # Sort: Folders first, then files
            items.sort(key=lambda x: (x['type'] != 'dir', x['name'].lower()))

            print(f"\nüìÇ Contents of '{repo_name}' (Limit: {limit}):")
            print("-" * 50)
            
            count = 0
            for item in items:
                if count >= limit:
                    break

                item_type = item['type'] # 'file' or 'dir'
                name = item['name']

                # Logic: fi (files only), fo (folders only), or all
                if mode == "fi" and item_type != "file":
                    continue
                if mode == "fo" and item_type != "dir":
                    continue

                # Print with icons
                if item_type == "dir":
                    print(f"üìÅ {name}/")
                    count += 1
                elif item_type == "file":
                    print(f"üìÑ {name}")
                    count += 1
            
            if count == 0:
                print("   (No items found matching criteria)")
            print("-" * 50 + "\n")

        else:
            print(f"‚ùå Failed to fetch contents: {response.json().get('message')}")

    def rename_repo(self, old_name, new_name):
        print(f"üîÑ Renaming '{old_name}' to '{new_name}'...")
        url = f"{self.base_url}/repos/{self.user}/{old_name}"
        data = {"name": new_name}
        response = requests.patch(url, json=data, headers=self.headers)
        
        if response.status_code == 200:
            print(f"‚úÖ Success! Repository renamed.")
            print(f"   Old Name: {old_name}")
            print(f"   New Name: {new_name}")
            print(f"   New URL: {response.json()['html_url']}")
        else:
            print(f"‚ùå Failed to rename: {response.json().get('message')}")

    def get_issues(self, repo_name):
        url = f"{self.base_url}/repos/{self.user}/{repo_name}/issues"
        params = {"state": "open"} 
        
        response = requests.get(url, headers=self.headers, params=params)
        
        if response.status_code == 200:
            issues = response.json()
            if not issues:
                print(f"‚úÖ No open issues found in '{repo_name}'.")
                return

            print(f"\nüêû Open Issues for '{repo_name}':")
            print("-" * 50)
            for issue in issues:
                if 'pull_request' in issue:
                    continue
                print(f"#{issue['number']} - {issue['title']}")
                print(f"   Created by: {issue['user']['login']}")
                print(f"   Link: {issue['html_url']}\n")
        else:
            print(f"‚ùå Failed to fetch issues: {response.json().get('message')}")

    def pull_repo(self, repo_name, path="."):
        print(f"‚¨áÔ∏è  Pulling (Downloading) '{repo_name}'...")
        
        repo_info_url = f"{self.base_url}/repos/{self.user}/{repo_name}"
        repo_resp = requests.get(repo_info_url, headers=self.headers)
        if repo_resp.status_code != 200:
            print(f"‚ùå Repository not found.")
            return
        
        default_branch = repo_resp.json().get("default_branch", "main")
        
        zip_url = f"{self.base_url}/repos/{self.user}/{repo_name}/zipball/{default_branch}"
        response = requests.get(zip_url, headers=self.headers, stream=True)
        
        if response.status_code == 200:
            try:
                z = zipfile.ZipFile(io.BytesIO(response.content))
                print(f"üì¶ Extracting to '{path}'...")
                z.extractall(path)
                print(f"‚úÖ Repository '{repo_name}' pulled successfully!")
            except Exception as e:
                print(f"‚ùå Error extracting zip: {e}")
        else:
            print(f"‚ùå Failed to download: {response.status_code} {response.reason}")

    def create_repo(self, name, private=False, description=""):
        url = f"{self.base_url}/user/repos"
        data = {
            "name": name,
            "private": private,
            "description": description,
            "auto_init": True 
        }
        response = requests.post(url, json=data, headers=self.headers)
        if response.status_code == 201:
            print(f"‚úÖ Repository '{name}' created successfully! (Private: {private})")
            print(f"   URL: {response.json()['html_url']}")
        else:
            print(f"‚ùå Failed to create repo: {response.json().get('message')}")

    def view_repo(self, name):
        url = f"{self.base_url}/repos/{self.user}/{name}"
        response = requests.get(url, headers=self.headers)
        if response.status_code == 200:
            repo = response.json()
            print(f"\nüì¶ Repository: {repo['name']}")
            print(f"   Description: {repo['description']}")
            print(f"   Private: {repo['private']}")
            print(f"   Stars: {repo['stargazers_count']}")
            print(f"   URL: {repo['html_url']}")
            print(f"   Clone: {repo['clone_url']}")
            print(f"   Open Issues: {repo['open_issues_count']}")
            print(f"   Default Branch: {repo['default_branch']}")
            print(f"   Last Updated: {repo['updated_at']}\n")
        else:
            print(f"‚ùå Repository not found or access denied.")

    def delete_repo(self, name):
        confirmation = input(f"‚ö†Ô∏è  Are you sure you want to DELETE '{self.user}/{name}'? This cannot be undone! (type 'yes'): ")
        if confirmation.lower() != 'yes':
            print("Operation cancelled.")
            return

        url = f"{self.base_url}/repos/{self.user}/{name}"
        response = requests.delete(url, headers=self.headers)
        if response.status_code == 204:
            print(f"üóëÔ∏è  Repository '{name}' deleted successfully.")
        else:
            print(f"‚ùå Failed to delete repo: {response.json().get('message')}")

    def set_visibility(self, name, private):
        url = f"{self.base_url}/repos/{self.user}/{name}"
        data = {"private": private}
        response = requests.patch(url, json=data, headers=self.headers)
        if response.status_code == 200:
            state = "Private" if private else "Public"
            print(f"üîí Repository '{name}' is now {state}.")
        else:
            print(f"‚ùå Failed to update visibility: {response.json().get('message')}")

    def get_file_sha(self, repo, path):
        url = f"{self.base_url}/repos/{self.user}/{repo}/contents/{path}"
        response = requests.get(url, headers=self.headers)
        if response.status_code == 200:
            return response.json()['sha']
        return None

    def upload_file(self, repo_name, local_path, target_path=None, commit_message=None):
        if not os.path.isfile(local_path):
            print(f"‚ùå Error: Local file '{local_path}' not found.")
            return

        filename = os.path.basename(local_path)
        remote_path = target_path if target_path else filename
        
        if target_path and not os.path.splitext(target_path)[1]: 
             remote_path = f"{target_path}/{filename}".replace("//", "/")

        try:
            with open(local_path, "rb") as f:
                content = base64.b64encode(f.read()).decode("utf-8")
        except Exception as e:
            print(f"‚ùå Error reading file: {e}")
            return

        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{remote_path}"
        
        sha = self.get_file_sha(repo_name, remote_path)
        message = f"Update {filename}" if sha else f"Create {filename}"
        if commit_message: 
            message = commit_message
        
        data = {
            "message": message,
            "content": content
        }
        if sha:
            data["sha"] = sha

        response = requests.put(url, json=data, headers=self.headers)
        if response.status_code in [200, 201]:
            action = "Updated" if sha else "Uploaded"
            print(f"‚úÖ {action} '{local_path}' -> '{remote_path}'")
        else:
            print(f"‚ùå Failed to upload '{local_path}': {response.json().get('message')}")

    def upload_folder(self, repo_name, local_folder, target_folder="", commit_message=None):
        if not os.path.isdir(local_folder):
            print(f"‚ùå Error: Local directory '{local_folder}' not found.")
            return

        IGNORE_DIRS = {'.git', '__pycache__', 'venv', 'env', '.idea', '.vscode', 'node_modules'}
        IGNORE_FILES = {'.DS_Store'}

        print(f"üìÇ Starting upload of folder '{local_folder}'...")
        
        for root, dirs, files in os.walk(local_folder):
            dirs[:] = [d for d in dirs if d not in IGNORE_DIRS]
            
            for file in files:
                if file in IGNORE_FILES:
                    continue

                local_file_path = os.path.join(root, file)
                if local_folder == ".":
                    relative_path = os.path.relpath(local_file_path, local_folder)
                else:
                    relative_path = os.path.relpath(local_file_path, local_folder)
                
                if target_folder:
                    remote_path = os.path.join(target_folder, relative_path).replace("\\", "/")
                else:
                    remote_path = relative_path.replace("\\", "/")
                
                if remote_path.startswith('/'):
                    remote_path = remote_path[1:]

                self._upload_file_direct(repo_name, local_file_path, remote_path, commit_message)
        print("üèÅ Upload complete.")

    def _upload_file_direct(self, repo_name, local_path, remote_path, commit_message=None):
        try:
            with open(local_path, "rb") as f:
                content = base64.b64encode(f.read()).decode("utf-8")
        except Exception as e:
            print(f"‚ùå Error reading file: {e}")
            return

        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{remote_path}"
        sha = self.get_file_sha(repo_name, remote_path)
        
        filename = os.path.basename(local_path)
        message = f"Update {filename}" if sha else f"Create {filename}"
        if commit_message:
            message = commit_message

        data = {"message": message, "content": content}
        if sha:
            data["sha"] = sha

        response = requests.put(url, json=data, headers=self.headers)
        if response.status_code in [200, 201]:
            action = "Updated" if sha else "Uploaded"
            print(f"‚úÖ {action} '{local_path}' -> '{remote_path}'")
        else:
            print(f"‚ùå Failed to upload '{local_path}': {response.json().get('message')}")

    def get_repo_contents(self, repo_name, path=""):
        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{path}"
        response = requests.get(url, headers=self.headers)
        if response.status_code == 200:
            return response.json()
        return None

    def delete_path(self, repo_name, remote_path, commit_message=None):
        print(f"Attempting to delete: {remote_path} from {repo_name}")
        contents = self.get_repo_contents(repo_name, remote_path)

        if contents is None:
            print(f"‚ùå Path '{remote_path}' not found in repo '{repo_name}'.")
            return False

        if isinstance(contents, list): 
            print(f"üìÇ Deleting folder '{remote_path}' recursively...")
            for item in contents:
                item_path = item['path']
                if not self.delete_path(repo_name, item_path, commit_message):
                    return False
            print(f"‚úÖ Folder '{remote_path}' and its contents deleted successfully.")
            return True
        else: 
            return self.delete_file(repo_name, remote_path, commit_message)

    def delete_file(self, repo_name, remote_path, commit_message=None):
        sha = self.get_file_sha(repo_name, remote_path)
        if not sha: return False

        url = f"{self.base_url}/repos/{self.user}/{repo_name}/contents/{remote_path}"
        data = {"message": f"Delete {remote_path}", "sha": sha}
        
        response = requests.delete(url, json=data, headers=self.headers)
        if response.status_code == 200:
            print(f"üóëÔ∏è  File '{remote_path}' deleted successfully.")
            return True
        else:
            print(f"‚ùå Failed to delete file '{remote_path}': {response.json().get('message')}")
            return False

def main():
    parser = argparse.ArgumentParser(description="GitHub CLI Manager", epilog=f"Version: {__version__}")
    parser.add_argument("--version", action="version", version=f"%(prog)s {__version__}")
    parser.add_argument("--token", help="GitHub Personal Access Token")
    
    subparsers = parser.add_subparsers(dest="command", required=False)

    check_account_parser = parser.add_argument_group("Global Commands")
    check_account_parser.add_argument("--check-account", action="store_true", help="Show the connected GitHub account")

    # Command: create
    create_parser = subparsers.add_parser("create", help="Create a new repository")
    create_parser.add_argument("name", help="Name of the repository")
    create_parser.add_argument("--private", action="store_true", help="Make repository private")
    create_parser.add_argument("--desc", default="", help="Description of the repository")

    # Command: view
    view_parser = subparsers.add_parser("view", help="View repository details")
    view_parser.add_argument("name", help="Name of the repository")

    # Command: rename 
    rename_parser = subparsers.add_parser("rename", help="Rename a repository")
    rename_parser.add_argument("old_name", help="Current name of the repository")
    rename_parser.add_argument("new_name", help="New name for the repository")

    # Command: ls (List contents)
    ls_parser = subparsers.add_parser("ls", help="List files and folders in a repo")
    ls_parser.add_argument("name", help="Name of the repository")
    ls_parser.add_argument("limit", nargs='?', default=100, type=int, help="Limit number of items displayed (default: 100)")
    ls_parser.add_argument("--fi", action="store_true", help="Show only files")
    ls_parser.add_argument("--fo", action="store_true", help="Show only folders")
    ls_parser.add_argument("--path", default="", help="Sub-folder path to list (optional)")

    # Command: issues
    issues_parser = subparsers.add_parser("issues", help="Get open issues from a repository")
    issues_parser.add_argument("name", help="Name of the repository")

    # Command: pull
    pull_parser = subparsers.add_parser("pull", help="Download (pull) the repository")
    pull_parser.add_argument("name", help="Name of the repository")
    pull_parser.add_argument("--dest", default=".", help="Destination folder (default: current directory)")

    # Command: delete
    delete_parser = subparsers.add_parser("delete", help="Delete a repository")
    delete_parser.add_argument("name", help="Name of the repository")

    # Command: visibility
    vis_parser = subparsers.add_parser("visibility", help="Change repo visibility")
    vis_parser.add_argument("name", help="Name of the repository")
    vis_parser.add_argument("--public", action="store_true", help="Make public")
    vis_parser.add_argument("--private", action="store_true", help="Make private")

    # Command: upload
    upload_parser = subparsers.add_parser("upload", help="Upload a specific file, folder, or the current directory to the repository")
    upload_parser.add_argument("repo", help="Target repository name")
    upload_parser.add_argument("path", default=".", nargs="?", help="Local file or folder path. Use '.' to upload the current directory.")
    upload_parser.add_argument("-m", "--message", help="Custom commit message (optional)")
    upload_parser.add_argument("--target", help="Target path/folder inside the repository")

    # Command: rm
    rm_parser = subparsers.add_parser("rm", help="Delete a file or folder from the repository")
    rm_parser.add_argument("repo", help="Repository name")
    rm_parser.add_argument("path", help="Path of the file or folder inside the repo to delete")

    args = parser.parse_args()

    token = args.token or os.environ.get("GITHUB_TOKEN")
    if not token:
        print("‚ùå Error: GitHub Token is required. Use --token or set GITHUB_TOKEN env var.")
        sys.exit(1)

    gh = GitHubManager(token)

    if args.check_account:
        print(f"Connected as: {gh.user}")
        return

    if args.command is None:
        parser.print_help()
        sys.exit(0)

    if args.command == "create":
        gh.create_repo(args.name, args.private, args.desc)
    elif args.command == "view":
        gh.view_repo(args.name)
    elif args.command == "rename":
        gh.rename_repo(args.old_name, args.new_name)
    
    # Logic for ls / view-fi-fo
    elif args.command == "ls":
        mode = "all"
        if args.fi and not args.fo:
            mode = "fi"
        elif args.fo and not args.fi:
            mode = "fo"
        
        gh.list_contents(args.name, args.limit, mode, args.path)

    elif args.command == "issues":
        gh.get_issues(args.name)
    elif args.command == "pull":
        gh.pull_repo(args.name, args.dest)
    elif args.command == "delete":
        gh.delete_repo(args.name)
    elif args.command == "visibility":
        if args.public and args.private:
            print("‚ùå Error: Cannot set both --public and --private.")
        elif args.public:
            gh.set_visibility(args.name, False)
        elif args.private:
            gh.set_visibility(args.name, True)
    elif args.command == "upload":
        local_path = args.path
        commit_message = args.message
        target_path = getattr(args, 'target', '')

        if local_path == ".":
            gh.upload_folder(args.repo, ".", target_path, commit_message)
        elif os.path.isfile(local_path):
            gh.upload_file(args.repo, local_path, target_path, commit_message)
        elif os.path.isdir(local_path):
            gh.upload_folder(args.repo, local_path, target_path, commit_message)
        else:
            print(f"‚ùå Error: Path '{local_path}' not found.")
    elif args.command == "rm":
        gh.delete_path(args.repo, args.path)

if __name__ == "__main__":
    main()
